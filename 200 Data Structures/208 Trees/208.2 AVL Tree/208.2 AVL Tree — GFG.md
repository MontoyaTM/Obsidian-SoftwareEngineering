Status: 
Tag:
Links:

---
> [!note] 
>  # AVL Tree

An AVL tree is a self-balancing binary search tree where the heights of the left and right subtrees of any node differ by at most one. This balancing property helps maintain the tree's efficiency by ensuring that the height of the tree remains logarithmic, which in turn keeps operations like insertion, deletion, and search within a logarithmic time complexity.

![[Pasted image 20230717112913.png]]


![[AVL Tree — Rotations.svg| 2000]]




> [!note] 
> ## Node 


A Node is a fundamental building block that is used to implement various data structures such as the Binary Tree. 
- <span style="color:#81fd83">data</span> — This component contains the actual data type information associated with the node.
- <span style="color:#81fd83">height</span> — This component contains the height associated with the node.
- <span style="color:#81fd83">left</span> — This component contains a reference to the left child Node in the Binary Tree. 
- <span style="color:#81fd83">right</span> — This component contains a reference to the right child Node of the Binary Tree.


![[AVL Tree — Node.svg | 350]]

``` run-csharp
public class Node
{
	public Node left;
	public Node right;
	public int data;
	public int height;

	public Node(int data)
	{
		this.left = null;
		this.right = null;
		this.data = data;
		this.height = 1;
	}
}
```


> [!note] 
> ## AVL Tree 


AVL tree is a <span style="color:#81fd83">self-balancing</span> Binary Search Tree (**BST**) where the difference between heights of left and right subtrees cannot be more than **one** for all nodes.

Most of the BST operations (e.g., search, max, min, insert, delete.. etc) take <span style="color:#81fd83">O(h)</span> time where **h** is the height of the BST. The cost of these operations may become **O(n)** for a **skewed Binary tree**. If we make sure that the height of the tree remains **O(log(n))** after every insertion and deletion, then we can guarantee an upper bound of <span style="color:#81fd83">O(log(n))</span> for all these operations. The height of an AVL tree is always **O(log(n))** where **n** is the number of nodes in the tree.

![[AVL Tree.svg]]

``` run-csharp
public class AVLTree
{
	Node root;
	
	public AVLTree()
	{
		this.root = null;
	}
}
```

``` run-csharp
public static void Main(string[] args)
{
	AVLTree tree = new AVLTree();
}
```

## Height Utility Method

The Height function is a utility method used to retrieve the height of the current node

``` run-csharp
public int Height(Node curr)
{
	if(curr == null)
	{
		return 0;
	}
	
	return curr.height;
}
```

## Maximum Node Utility Method

The Maximum function is a utility method used to retrieve the maximum of two values

``` run-csharp
public int Maximum(int a, int b)
{
	return (a > b) ? a : b;
}
```

## Balance Factor

The BalanceFactor function is a utility method to retrieve the balance factor of the current node.

![[AVL Tree — Balance Factor.svg| 400]]


``` run-csharp 
public int BalanceFactor(Node curr)
{
	if(curr == null) 
	{
		return 0;
	}
	
	return Height(curr.left) - Height(curr.right);
}
```


## RightRotate()

![[AVL Tree — Right Rotation.svg]]


``` run-csharp
public Node RightRotate(Node y)
{
	Node x = y.left;
	Node T2 = x.right;
	
	// Perform Rotation
	x.right = y;
	y.left = T2;
	
	// Update Height
	y.height = max(Height(y.left), Height(y.right)) + 1;
	x.height = max(Height(x.left), Height(x.right)) + 1;
	
	return x;
}
```








---
References: https://www.geeksforgeeks.org/insertion-in-an-avl-tree/